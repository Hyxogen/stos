use anyhow::{Context, Error, Result};
use log::LevelFilter;
use rand::random;
use std::path::PathBuf;

const DEFAULT_DECK_FILE: &str = "deck.apkg";
const DEFAULT_DECK_NAME: &str = "Stos Deck";
const DEFAULT_DECK_DESC: &str = "A deck generated by stos";
const DEFAULT_AUDIO_FORMAT: &str = "out_%f_%s.mka";
const DEFAULT_IMAGE_FORMAT: &str = "out_%f_%s.jpg";

fn print_help(executable: &str) {
    println!("USAGE:");
    println!(
        "    {} [OPTIONS] <SUBTITLE_FILE>... [-o <DECK>]",
        executable
    );
    println!(
        "    {} [OPTIONS] <SUBTITLE_FILE>... [-a | -i] [-m MEDIA_FILES...]",
        executable
    );
    println!("    {} -h | --help", executable);
    println!("    {} --version", executable);
    println!();
    println!("OPTIONS:");
    println!("    -h, --help                    Print a this help message and exit.");
    println!("    --version                     Print version and exit.");
    println!("    -v                            Increase verbosity of program logs.");
    println!("    -o FILE, --output=FILE        Specify the file to write the anki deck to [default: {}].", DEFAULT_DECK_FILE);
    println!("    -s INDEX, --sub-stream=INDEX  Select which stream to use from SUBTITLE_FILE as the subtitle stream.");
    println!("    -a, --audio                   Generate audio snippets for the anki cards.");
    println!("    --audio-stream=INDEX          Select which stream to use to generate the audio snippets.");
    println!("    --audio-format=FORMAT         Specify how the audio files should be named [default: {}].", DEFAULT_AUDIO_FORMAT);
    println!("    -i, --image                   Generate images for the anki cards.");
    println!(
        "    --image-stream=INDEX          Select which stream to use to generate the images."
    );
    println!("    --image-format=FORMAT         Specify how the image files should be named [default: {}].", DEFAULT_IMAGE_FORMAT);
    println!("    -m, --media                   Specify media files from which to generate the audio snippets (-a) or images (-i).");
    println!("    -c, --coalesce                Merge overlapping audio snippets to one");
    println!("    --no-deck                     Do not write a anki deck package");
    println!(
        "    --name=NAME                   Specify the name to give the anki deck [default: {}]",
        DEFAULT_DECK_NAME
    );
    println!("    --desc=DESC                   Specify the description to give the anki deck [default: {}]", DEFAULT_DECK_DESC);
}

pub struct Args {
    pub executable: String,
    pub sub_files: Vec<PathBuf>,
    pub sub_stream: Option<usize>,
    pub sub_format: String,

    pub coalesce: bool,

    pub media_files: Vec<PathBuf>,

    pub gen_audio: bool,
    pub audio_stream: Option<usize>,
    pub audio_format: String,

    pub gen_image: bool,
    pub image_format: String,

    pub no_media: bool,
    pub no_deck: bool,

    pub deck_id: i64,
    pub deck_name: String,
    pub deck_desc: String,
    pub package: PathBuf,

    pub verbosity: LevelFilter,
}

impl Default for Args {
    fn default() -> Self {
        Self {
            executable: env!("CARGO_PKG_NAME").to_string(),
            sub_files: Default::default(),
            sub_stream: Default::default(),
            sub_format: "sub_%f_%s_%r.jpg".to_string(),
            coalesce: false,
            media_files: Default::default(),
            gen_audio: false,
            audio_stream: Default::default(),
            audio_format: DEFAULT_AUDIO_FORMAT.to_string(),
            gen_image: false,
            image_format: DEFAULT_IMAGE_FORMAT.to_string(),
            no_media: false,
            no_deck: false,
            deck_id: random(),
            deck_name: DEFAULT_DECK_NAME.to_string(),
            deck_desc: DEFAULT_DECK_DESC.to_string(),
            package: DEFAULT_DECK_FILE.into(),
            verbosity: LevelFilter::Error,
        }
    }
}

impl Args {
    pub fn parse_from_env() -> Result<Self> {
        use lexopt::prelude::*;

        let mut args = Args::default();
        let mut subtitles = true;

        let mut parser = lexopt::Parser::from_env();

        if let Some(executable) = parser.bin_name() {
            args.executable = executable.to_string();
        }

        while let Some(arg) = parser.next()? {
            match arg {
                Short('m') | Long("media") => {
                    subtitles = false;
                }
                Short('s') | Long("sub-stream") => {
                    args.sub_stream = Some(parser.value()?.parse()?);
                }
                Short('a') | Long("audio") => {
                    args.gen_audio = true;
                }
                Long("audio-stream") => {
                    args.audio_stream = Some(parser.value()?.parse()?);
                }
                Long("audio-format") => {
                    args.audio_format = if let Ok(format) = parser.value()?.into_string() {
                        format
                    } else {
                        eprintln!("Failed to parse \"--audio-format\" option: Invalid unicode");
                        std::process::exit(1);
                    }
                }
                Short('i') | Long("image") => {
                    args.gen_image = true;
                }
                Long("image-format") => {
                    args.image_format = if let Ok(format) = parser.value()?.into_string() {
                        format
                    } else {
                        eprintln!("Failed to parse \"--image-format\" option: Invalid unicode");
                        std::process::exit(1);
                    }
                }
                Long("no-media") => {
                    args.no_media = true;
                }
                Long("no-deck") => {
                    args.no_deck = true;
                }
                Long("name") => {
                    args.deck_name = parser
                        .value()?
                        .into_string()
                        .map_err(|_| Error::msg("Invalid unicode"))
                        .context("Failed to parse option \"--name\"")?;
                }
                Long("desc") => {
                    args.deck_desc = parser
                        .value()?
                        .into_string()
                        .map_err(|_| Error::msg("Invalid unicode"))
                        .context("Failed to parse option \"--desc\"")?;
                }
                Short('c') | Long("coalesce") => {
                    args.coalesce = true;
                }
                Short('o') | Long("output") => {
                    args.package = parser.value()?.into();
                }
                Short('v') => {
                    args.verbosity = LevelFilter::Warn;

                    if let Some(val) = parser.optional_value() {
                        args.verbosity = match val.into_string().as_deref() {
                            Ok("v") => LevelFilter::Info,
                            Ok("vv") => LevelFilter::Debug,
                            Ok("vvv") => LevelFilter::Trace,
                            Ok(val) => {
                                eprintln!(
                                    "\"{}\" is not a valid value for the verbosity flag \"-v\"",
                                    val
                                );
                                std::process::exit(1);
                            }
                            Err(val) => {
                                eprintln!(
                                    "Failed to parse verbosity option: Invalid unicode: {}",
                                    val.to_string_lossy()
                                );
                                std::process::exit(1);
                            }
                        }
                    }
                }
                Value(val) if subtitles => {
                    args.sub_files.push(val.into());
                }
                Value(val) if !subtitles => {
                    args.media_files.push(val.into());
                }
                Short('h') | Long("help") => {
                    print_help(&args.executable);
                    std::process::exit(0);
                }
                Long("version") => {
                    println!("{} {}", env!("CARGO_PKG_NAME"), env!("CARGO_PKG_VERSION"));
                    std::process::exit(0);
                }
                Short(option) => {
                    println!("Unknown option \"-{}\"", option);
                    println!();
                    print_help(&args.executable);
                    std::process::exit(1);
                }
                Long(option) => {
                    println!("Unknown option \"--{}\"", option);
                    println!();
                    print_help(&args.executable);
                    std::process::exit(1);
                }
                _ => panic!(),
            }
        }

        if args.sub_files.is_empty() {
            println!("The following argument was not provided:");
            println!("    <SUBTITLE_FILE>");
            println!();
            print_help(&args.executable);
            std::process::exit(0);
        }
        Ok(args)
    }
}
